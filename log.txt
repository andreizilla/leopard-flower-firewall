---------------------IMPORTANT----------------------
This log is kept in its full form more as a legacy than a reference, a lot of code and design has been altered in the process, please don't rely on what's written here.
----------------------------------------------------

The daemon should be run as root, otherwise you'll get nfq_bind errors
modprobe nfnetlink_queue something

10 Oct.
queueHandle isnt receiving packets, it may be due to the fact that nfq_handle_packet calls it from a different thread. Needs investigation.
sorted, I used NFQNL_COPY_NONE wrongly.
---
11 Oct.
Trying to sort out FIFO - it acts very strangely
FIFO snag:
First open the fifo, only THEN launch ulogd, when restart kill ulogd, open FIFO and launch ulogd anew
I need to set mutex on list, otherise results will be unpredictable;
I discovered that packet comes to NFQUEUE first, so it may need to wait a little before ulog processes
and spits out the log info

setcap cap_net_admin=ep /home/wwwwww/Desktop/tuxg/daemon-build-desktop/daemon
---
29 Oct 2010
Now, we dont use ULOGD but extract tcp/ip headers from packet directly. We may go back to ULOD for the purposes of gathering statistics.
If we allow daemon to process every single packet, i.e extract port,inode,path then the CPU usage spikes to up to 90%. In order to decrease the amount of CPU cycles, I decided to use conntrack module of netfiilet, now the iptable rule reads:
Thus, we filter only those packets which initiate a connection, we dont need to worry about subsequent packets. Still, CPU usage may spike on torrent clients which create lots of new connections,thus our daemon has to process them all.
Today I finally managed to put daemon and frontend together and make them work, It is time for feature freeze and getting ready to release the product.

For communication between daemon and frontend I tried
QSharedMemory but its lock mechanism seemed broken, I tried to lock it using system semaphores, but their acted strangely, I even tried POSIX semaphores,but they also were erratic. Luckily we have kernel message queues, which we are now utilising.

Let me give a brief rundown on the architecture of the firewall:
We add this rule to iptables:
iptables -A OUTPUT -p tcp -m state --state NEW -j NFQUEUE
(and modprobe ip_conntrack if necessary)
and registed a netfilet_queue hook, this way all outgoing packets that represent a request for a new connection are channeled to the daemon,the daemon  extracts ip & tcp header and source port, with this source port it then polls /proc/net/tcp to determine which inode is associated to that port. Having found the inode, it then scans /proc to find a path to application associated with that inode (i.e. socket). Lastly it sends the path & PID to frontend, waits for a response and ACCEPTS or DROPS packet accordingly.
Note: we deal only with packets which conntrack marked as NEW. If an app tries to establish a connection, the packet it sends will be marked as NEW, and if we drop it then the app will try to send couple of more of those NEW packets (Skype e.g. will flood us with those packets) thus increasing CPU consumption by the daemon. Conversely, if we allow an app which sent a NEW packet, then subsequent packets for that connection will NOT be marked as NEW and will not trigger our iptables rule, thus alleviating our daemon from unnecessary checks.

An idea came to me to rewrite daemon completely in C so as to get rid of all Qt dependencies
Rewritten..
---
10 Nov 2010
Jobs for tomorrow: add mutexes everywhere and take care of
refresh_thread
I'm sick and tired today. This stupid laptop just powered off and I lost my last 30 mins of work even though I was constantly saving it. I cant stand to code the same stuff over. So, I'm gonna leave it for tomorrow. So long
---
11 Nov
rewrite pathAloowed using dynarray ...All done

iptables -I OUTPUT 1 -p all -m state --state NEW -j NFQUEUE --queue-num 11220
iptables -I OUTPUT 1 -p tcp -m tcp --dport 11222 -j ACCEPT

gdbserver localhost:11222 /media/0233b323-129f-4bfa-bb5e-3331a1b81c35/home/wwwwww/Desktop/tuxg/lpfwcli-build-desktop/lpfwcli
---
18 Nov 2010
Need a lil rewrite because daemon blocks even those packets that are allowed until frontend issues verdict. This ought not to be so, allowed packets should come through while user is in interactive mode....done
---
20 Nov
Implementing UDP filtering...
Wrapping my head around struct iphdr
---
23 Nov
We need to make sure lpfw.rules gets created  , we also need lpfw.conf containing settings
---
31 Dec 2010
a simple rule for upstart now launches daemon at boot easily.
Now, daemon should exec iptables and add a rule
Let's prevent daemon from running in two instances:
1. create lpfw.pid in /var/run and write our PID in there
2. if file already exists, read PID therein
3. check if
- this PID is running && 
- is our application && 
- is NOT actually us (if the system crashed and upon reboot lpfw got the same PID as the previous time - rare, but possible). 
if so, refuse to start
---
5 Jan 2011
After struggling for some while with running daemon under debugger (gdb), I decided to separate from the daemon a small section of code and make it a separate executable. The section of code in question is specifically the one which requires root privileges to read /proc/<pid>/exe and readlink in /proc/<pid>/fd
The other part has to have cap_net_admin capability (and possibly CAP_DAC_READ_SEARCH) set, though.

Worker process should consist of:
thread 1:
assigns cap_net_admin capabilities to daemon process.
thread 2:
checks inodes in /proc and reports whether it's been found   

No, the plan didnt work out mainly because linux doesnt allow one process to change another process's posix capabilities.
But the solution was found in runnign sudo gdb instead of setting suid bit. 

Actually, none of the above proved to work and I ended with sudo qtcreator. That's it.

Done creating lpfw.pid mechanism.
Now we need to exit gracefully upon shutdown, viz.
1. Write config file
2. Remove lpfw.pid
Done.
---
7 Jan 2011
Let's hone the sourcecode a bit, put in more comments.
---
8 Jan
Implementing logging based on rsyslog. Done for lpfw, (to do for lpfwcli ?)
---
10 Jan
I looked into changing d<>f IPC from MSGQ to defice file (like in /dev) but it proved impossible without FUSD library. So I'm gonna start coding dbus IPC now.
lpfwcli: delete interactive mode, we just need a signal that daemon is asking us something, then when we press abutton, we can see the last query. For this we need a separate thread which listens to the daemon stuff. In short we need to remake cli interface to something top-like - with real-time notifications/changes
---
11 Jan
in addition to the above it would be nice to have wrapper functions around message send ones , so we dont have to deal with msg types directly
Also cli version is gonna run on ncurses:)
---
18 Jan
Milestones that need to be achieved to release ncurses version:
msgq interface should be plugable
functions that should work: list, del, add, write
That's it
---
7 Feb
Still struggling with msgq plugability